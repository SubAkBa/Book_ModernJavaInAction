## 18.1 시스템 구현과 유지보수
### 18.1.1 공유된 가변 데이터
변수가 예상하지 못한 값을 갖는 이유는 결국 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다.

공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기가 어려워진다.

어떤 자료구조도 바꾸지 않는 시스템이 있다고 가정하자. 예상하지 못하게 자료구조의 값이 바뀔 일이 없으니 얼마나 유지보수하기 쉽겠는가!
자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 **순수** 메서드 또는 **부작용 없는** 메서드라고 부른다.

구체적으로 부작용은 무엇일까? 함수 내에 포함되지 못한 기능을 부작용이라고 한다.
- 자료구조를 고치거나 필드에 값을 할당 (setter 메서드 같은 생성자 이외의 초기화 동작)
- 예외 발생
- 파일에 쓰기 등의 I/O 동작 수행

**불변 객체를 이용해서 부작용을 없애는 방법도 있다.**

불변 객체는 인스턴스화한 다음에는 객체의 상태를 바꿀 수 없는 객체이므로 함수 동작에 영향을 받지 않는다. 즉, 인스턴스화한 불변 객체의 상태는 결코 예상하지 못한 상태로 바뀌지 않는다.
따라서 불변 객체는 복사하지 않고 공유할 수 있으며, 객체의 상태를 바꿀 수 없으므로 스레드 안정성을 제공한다.

부작용 없는 시스템 컴포넌트에서는 메서드가 서로 간섭하는 일이 없으므로 잠금을 사용하지 않고도 멀티코어 병렬성을 사용할 수 있다. 또한 프로그램의 어떤 부분이 독립적인지 바로 이해할 수 있다.

### 18.1.2 선언형 프로그래밍
'어떻게 (how)' 에 집중하는 프로그래밍 형식은 고전의 객체지향 프로그래밍에서 이용하는 방식이다. 때로는 이를 명령형 프로그래밍이라고 부르기도 하는데 다음 코드에서 보여주는 것처럼 명령어가 컴퓨터의 저수준 언어와 비슷하게 생겼기 때문이다.
```java
Transaction mostExpensive = transactions.get(0);
if (mostExpensive == null) {
    throw new IllegalArgumentException("Empty list of transaction");
}

for (Transaction t : transactions.subList(1, transactions.size())) {
    if (t.getValue() > mostExpensive.getValue()) {
        mostExpensive = t;
    }
}
```

'어떻게' 가 아닌 '무엇을' 에 집중하는 방식도 있다.
```java
Optional<Transaction> mostExpensive = 
    transactions.stream()
        .max(comparing(Transaction::getValue));
```

이와 같은 구현 방식을 **내부 반복**이라고 한다. 질의문 자체로 문제를 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 큰 장점이다.

이처럼 '무엇을' 에 집중하는 방식을 선언형 프로그래밍이라고 부른다. 선언형 프로그래밍에서는 우리가 원하는 것이 무엇이고 시스템이 어떻게 그 목표를 달성할 것인지 등의 규칙을 정한다.
문제 자체가 코드로 명확하게 드러난다는 점이 선언형 프로그래밍의 강점이다.

### 18.1.3 왜 함수형 프로그래밍인가?
함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며, 부작용이 없는 계산을 지향한다. 선언형 프로그래밍과 부작용을 멀리한다는 두 가지 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.