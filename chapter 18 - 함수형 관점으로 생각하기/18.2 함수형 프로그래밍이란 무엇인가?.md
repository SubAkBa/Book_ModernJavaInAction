## 18.2 함수형 프로그래밍이란 무엇인가?
int와 double을 인수로 받아서 double을 반환하는 메서드가 있는데 이 메서드는 자신이 호출된 횟수로 가변 변수를 갱신하는 부작용을 포함하고 있다.

함수형 프로그래밍에서 **함수**란 수학적인 함수와 같다. 즉, 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 **부작용이 없어야 한다.**

자바와 같은 언어에서는 바로 수학적인 함수냐 아니냐가 메서드와 함수를 구분하는 핵심이다 (log, sin 등의 수학적 함수는 절대 부작용을 포함하지 않을 것이다). 특히 인수가 같다면 수학적 함수를 반복적으로 호출했을 때 항상 같은 결과가 반환된다.
하지만 Random.nextInt 같은 메서드에는 이런 규칙이 적용되지 않는데 이와 관련된 내용은 참조 투명성을 살펴보면서 설명한다.

**함수형**이라는 말은 '수학의 함수처럼 부작용이 없는'을 의미한다. 호출자에 아무 영향을 미치지 않는다면 호출자는 내부적인 부작용을 파악하거나 신경 쓸 필요가 없다.

결론적으로 '함수 그리고 if-then-else 등의 수학적 표현만 사용'하는 방식을 순수 함수형 프로그래밍이라고 하며 '시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용'하는 방식을 함수형 프로그래밍이라 한다.

### 18.2.1 함수형 자바
자바에서는 순수 함수형이 아니라 **함수형 프로그램**을 구현할 것이다. 

함수나 메서드는 지역 변수만을 변경해야 **함수형**이라 할 수 있다. 그리고 함수나 메서드에서 참조하는 객체가 있다면 그 객체는 불변 객체여야 한다. 즉, 객체의 모든 필드가 final이어야 하고 모든 참조 필드는 불변 객체를 직접 참조해야 한다.

예외적으로 메서드 내에서 생성한 객체의 필드는 갱신할 수 있다는 사실을 살펴볼 것이다. 단, 새로 생성한 객체의 필드 갱신이 외부에 노출되지 않아야 하고 다음에 메서드를 다시 호출한 결과에 영향을 미치지 않아야 한다.

함수형이라면 **함수나 메서드가 어떤 예외도 일으키지 않아야 한다.** 예외가 발생하면 블랙박스 모델에서 return으로 결과를 반환할 수 없게 될 수 있기 때문이다. 이러한 제약은 함수형을 수학적으로 활용하는 데 큰 걸림돌이 될 것이다.  
**수학적 함수**는 주어진 인수값에 대응하는 하나의 결과를 반환한다. 실제 대부분의 연산은 **부분 함수**로 활용된다.

예외를 사용하지 않고 나눗셈 같은 함수를 표현하려면 어떻게 해야 할까? 바로 Optional< T > 를 사용하면 이 문제를 해결할 수 있다.
double sqrt(double) 대신 Optional< Double > sqrt(double) 을 이용하면 예외 없이도 결과값으로 연산을 성공적으로 수행했는지 아니면 요청된 연산을 성공적으로 수행하지 못했는지 확인할 수 있다.   
즉, 호출자는 메서드 호출 결과로 빈 Optional이 반환되는지 확인해야 한다.

마지막으로 함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다.
> 즉, 먼저 자료구조를 복사한다든가 발생할 수 있는 예제를 적절하게 내부적으로 처리함으로써 자료구조의 변경을 호출자가 알 수 없도록 감춰야 한다.

### 18.2.2 참조 투명성
'부작용을 감춰야 한다'라는 제약은 **참조 투명성** 개념으로 귀결된다. 즉, 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.
> 예를 들어 "raoul".replace('r', 'R') 코드는 항상 같은 결과가 나오므로 String.replace는 참조적으로 투명하다 (String.replace는 this 객체를 갱신하는 것이 아니라 대문자 'R'을 소문자 'r'로 바꿔서 **새로운** String을 반환한다).

다시 말해, 함수는 어떤 입력이 주어졌을 때 언제, 어디서 호출하든 같은 결과를 생성해야 한다. 따라서 Random.nextInt는 함수형이 될 수 없다.

참조 투명성은 프로그램 이해에 큰 도움을 준다. 또한 참조 투명성은 비싸거나 오랜 시간이 걸리는 연산을 **기억화** 또는 **캐싱**을 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공한다.

> 자바에는 참조 투명성과 관련한 작은 문제가 있다.
> 
> List를 반환하는 메서드를 두 번 호출한다고 가정하자. 두 번의 호출 결과로 같은 요소를 포함하지만 서로 다른 메모리 공간에 생성된 리스트를 참조할 것이다.  
> 결과 리스트가 가변 객체라면 (반환된 두 리스트가 같은 객체라 할 수 없으므로) 리스트를 반환하는 메서드는 참조적으로 투명한 메서드가 아니라는 결론이 나온다.  
> 결과 리스트를 (불변의) 순수값으로 사용할 것이라면 두 리스트가 같은 객체라고 볼 수 있으므로 리스트 생성 함수는 참조적으로 투명한 것으로 간주할 수 있다.
> 
> 일반적으로 **함수형 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주한다.**

### 18.2.3 객체지향 프로그래밍과 함수형 프로그래밍
프로그래밍 형식을 스펙트럼으로 표현하자면 스펙트럼의 한 쪽 끝에는 모든 것을 객체로 간주하고 프로그램이 객체의 필드를 갱신하고, 메서드를 호출하고, 관련 객체를 갱신하는 방식으로 동작하는 익스트림 객체지향 방식이 위치한다.

스펙트럼의 반대쪽 끝에는 참조적 투명성을 중시하는, 즉 변화를 허용하지 않는 함수형 프로그래밍 형식이 위치한다. 실제로 자바 프로그래머는 두 가지 프로그래밍 형식을 혼합한다.

예를 들어 Iterator로 가변 내부 상태를 포함하는 자료구조를 탐색하면서 함수형 방식으로 자료구조에 들어 있는 값의 합계를 계산할 수 있다 (이미 설명했듯이 자바에서는 지역 변수 변화가 수반될 수 있다).

### 18.2.4 함수형 실전 연습
{1, 4, 9} 처럼 List< Integer > 가 주어졌을 때 이것의 모든 서브집합의 멤버로 구성된 List< List < Integer >> 를 만드는 프로그램을 만든다고 가정하자.
예를 들어 {1, 4, 9}의 서브집합은 {1, 4, 9}, {1, 4}, {1, 9}, {4, 9}, {1}, {4}, {9}, {}다. 빈 집합 {}를 포함해서 총 8개의 서브집합이 존재한다.
각 서브집합은 List< Integer > 형식으로 이루어져 있으므로 최종 정답의 형식은 List< List < Integer >>다.

보통 '{1, 4, 9}의 서브집합 중 1을 포함하는 집합과 아닌 집합'으로 구분해서 문제를 풀려 시도할 것이다. 이와 같은 접근 방식은 가장 쉽고, 자연스러운 함수형 자바 프로그래밍이다
(여기서 가장 많이 하는 실수는 빈 리스트는 부분집합이 없다고 착각하는 것이다).
```java
static List<List<Integer>> subsets(List<Integer> list) {
    if (list.isEmpty()) {                                  // <- 입력 리스트가 비어있다면 빈 리스트 자신이 서브집합이다.
        List<List<Integer>> ans = new ArrayList<>();
        ans.add(Collections.emptyList());
        return ans;
    }
	
    Integer first = list.get(0);
    List<Integer> rest = list.subList(1, list.size());
    
    List<List<Integer>> subans = subsets(rest);            // <- 빈 리스트가 아니면 먼저 하나의 요소를 꺼내고 나머지 요소의 모든 서브집합을 찾아서 subans로 전달한다. subans는 절반의 정답을 포함한다.
    List<List<Integer>> subans2 = insertAll(first, subans); // <- 정답의 나머지 절반을 포함하는 subans2는 subans의 모든 리스트에 처음 꺼낸 요소를 앞에 추가해서 만든다.
    return concat(subans, subans2); // <- subans, subans2를 연결하면 정답이 완성된다.
}
```

insertAll과 concat 두 개의 함수형 메서드의 구현이 없다는 사실을 파악했을 것이다. 또한 subsets 자체도 기존의 구조를 갱신하지 않으므로 함수형이다.

insertAll을 정의해보자. 첫 번째 함정이 나타났다. 만약 여러분이 insertAll의 인수를 변환하도록, 즉 subans의 모든 요소가 first를 포함하도록 인수를 변환했다고 가정하자.
결국 subans가 의도하지 않은 값을 포함하면서 이상한 결과가 나온다. 따라서 다음처럼 insertAll을 정의해야 한다.
```java
static List<List<Integer>> insertAll(Integer first, List<List<Integer>> lists) {
    List<List<Integer>> result = new ArrayList<>();
    
    for (List<Integer> list : lists) {
        List<Integer> copyList = new ArrayList<>(); // <- 리스트를 복사한 다음에 복사한 리스트에 요소를 추가한다.
        copyList.add(first);                         //    구조체가 가변이더라도 저수준 구조를 복사하진 않는다 (Integer는 가변이 아니다).
        copyList.addAll(list);
        result.add(copyList);
    }
    
    return result;
}
```

subans의 모든 요소를 포함하는 새로운 List를 만들었다는 점에 주목하라. 여기서는 Integer 객체가 불변이라는 사실을 이용했다 (Integer가 불변이 아니라면 각 요소를 모두 복제해야 한다).
insertAll을 함수형으로 만들어야 하므로 이처럼 호출자가 아니라 insertAll 내부에 리스트를 복사하는 코드를 추가하는 것이 자연스럽다.

마지막으로 concat 메서드를 정의한다.
```java
static List<List<Integer>> concat(List<List<Integer>> a, List<List<Integer>> b) {
    a.addAll(b);
	
    return a;
}

// 이처럼 구현하는 것이 바람직하다.
static List<List<Integer>> concat(List<List<Integer>> a, List<List<Integer>> b) {
    List<List<Integer>> r = new ArrayList<>(a);
    r.addAll(b);
    
    return r;
}
```

두 번째 버전의 concat은 순수 함수다. 내부적으로는 리스트 r에 요소를 추가하는 변화가 발생하지만 반환 결과는 오로지 인수에 의해 이루어지며 인수의 정보는 변경하지 않는다.
이와 달리 첫 번째 버전은 concat(subans, subans2)를 호출한 다음에 subans의 값을 다시 참조하지 않는다는 가정을 한다.