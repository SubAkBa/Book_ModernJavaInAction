## 13.4 해석 규칙
### 13.4.1 알아야 할 세 가지 해결 규칙
다른 클래스나 인터페이스로부터 같은 시그니처를 갖는 메서드를 상속받을 때는 세 가지 규칙을 따라야 한다.
1. 클래스가 항상 이긴다. 클래스나 슈퍼클래스에서 정의한 메서드가 디폴트 메서드보다 우선권을 갖는다.
2. 1번 규칙 이외의 상황에서는 서브인터페이스가 이긴다. 상속관계를 갖는 인터페이스에서 같은 시그니처를 갖는 메서드를 정의할 때는 서브인터페이스가 이긴다. 즉, B가 A를 상속받는다면 B가 A를 이긴다.
3. 여전히 디폴트 메서드의 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스가 명시적으로 디폴트 메서드를 오버라이드하고 호출해야 한다.

### 13.4.2 디폴트 메서드를 제공하는 서브인터페이스가 이긴다
B와 A는 hello라는 디폴트 메서드를 정의한다. 또한 B는 A를 상속받는다.

컴파일러는 누구의 hello 메서드 정의를 사용할까? 2번 규칙에서는 서브인터페이스가 이긴다고 설명한다. 

즉, B가 A를 상속받았으므로 컴파일러는 B의 hello를 선택한다. 따라서 프로그램은 'Hello from B'를 출력한다.

```java
public class D implements A { }
public class C extends D implements B, A {
    public static void main(String... args) {
        new C().hello(); // <- 무엇이 출력될까?
    }
}
```

1번 규칙은 클래스의 메서드 구현이 이긴다고 설명한다. D는 hello를 오버라이드하지 않았고 단순히 인터페이스 A를 구현했다. 따라서 D는 인터페이스 A의 디폴트 메서드 구현을 상속받는다.

2번 규칙에서는 클래스나 슈퍼클래스에 메서드 정의가 없을 때는 디폴트 메서드를 정의하는 서브인터페이스가 선택된다. 따라서 컴파일러는 인터페이스 A의 hello나 인터페이스 B의 hello 둘 중 하나를 선택해야 한다.
여기서 B가 A를 상속받는 관계이므로 이번에도 'Hello from B'가 출력된다.

### 13.4.3 충돌 그리고 명시적인 문제 해결
B가 A를 상속받지 않는 상황이라고 가정하자.
```java
public interface A {
    default void hello() {
        System.out.println("Hello from A");
    }
}

public interface B {
    default void hello() {
        System.out.println("Hello from B");
    }
}

public class C implements B, A { }
```

인터페이스 간에 상속관계가 없으므로 2번 규칙을 적용할 수 없다. 그러므로 A와 B의 hello 메서드를 구별할 기준이 없다.

따라서 자바 컴파일러는 어떤 메서드를 호출해야 할 지 알 수 없으므로 "Error: class C inherits unrelated defaults for hello() from types B and A.' 같은 에러가 발생한다.

**충돌 해결**

클래스와 메서드 관계로 디폴트 메서드를 선택할 수 없는 상황에서는 선택할 수 있는 방법이 없다. 개발자가 직접 클래스 C에서 사용하려는 메서드를 명시적으로 선택해야 한다.

즉, 클래스 C에서 hello 메서드를 오버라이드한 다음에 호출하려는 메서드를 명시적으로 선택해야 한다. **자바 8에서는 X.super.m(...)** 형태의 새로운 문법을 제공한다.
여기서 X는 호출하려는 메서드 m의 슈퍼인터페이스다.
```java
public class C implements B, A {
    void hello() {
        B.super.hell(); // <- 명시적으로 인터페이스 B의 메서드를 선택한다.
    }
}
```

### 13.4.4 다이아몬드 문제
```java
public interface A {
    default void hello() {
        System.out.println("Hello from A");
    }
}
public interface B extends A { }
public interface C extends A { }
public class D implements B, C {
    public static void main(String... args) {
        new D().hello(); // <- 무엇이 출력될까?
    }
}
```

D는 B와 C 중 누구의 디폴트 메서드 정의를 상속받을까? 

실제로 선택할 수 있는 메서드 선언은 하나뿐이다. A만 디폴트 메서드를 정의하고 있다. 따라서 결국 프로그램 출력 결과는 'Hello from A'가 된다.

B에서 같은 시그니처의 디폴트 메서드 hello가 있다면 어떻게 될까? 2번 규칙은 디폴트 메서드를 제공하는 가장 하위의 인터페이스가 선택된다고 했다. B는 A를 상속받으므로 B가 선택된다.
B와 C가 모두 디폴트 메서드 hello 메서드를 정의한다면 충돌이 발생하므로 이전에 설명한 것처럼 둘 중 하나의 메서드를 명시적으로 호출해야 한다.

<br />

다음처럼 인터페이스 C에 추상 메서드 hello (디폴트 메서드가 아님) 를 추가하면 어떤 일이 벌어질까? (A와 B에는 아무 메서드도 정의하지 않는다)
```java
public interface C extends A {
    void hello();
}
```

C는 A를 상속받으므로 C의 추상 메서드 hello가 A의 디폴트 메서드 hello보다 우선권을 갖는다. 따라서 컴파일 에러가 발생하며, 클래스 D가 어떤 hello를 사용할지 명시적으로 선택해서 에러를 해결해야 한다.

> C++ 다이아몬드 문제
> 
> C++은 클래스의 다중 상속을 지원한다. 클래스 D가 클래스 B와 C를 상속받고 B와 C는 클래스 A를 상속받는다고 가정하자.  
> 그러면 클래스 D는 B 객체와 C 객체의 복사본에 접근할 수 있다. 결과적으로 A의 메서드를 사용할 때 B의 메서드인지 C의 메서드인지 명시적을 해결해야 한다.  
> 또한 클래스는 상태를 가질 수 있으므로 B의 멤버 변수를 고쳐도 C 객체의 복사본에 반영되지 않는다.

같은 디폴트 메서드 시그니처를 갖는 여러 메서드를 상속받는 문제를 쉽게 해결할 수 있음을 살펴봤다. 다음과 같은 세 가지 규칙만 적용하면 모든 충돌 문제를 해결할 수 있다.
1. 클래스가 항상 이긴다. 클래스나 슈퍼클래스에서 정의한 메서드가 디폴트 메서드보다 우선권을 갖는다.
2. 위 규칙 이외의 상황에서는 서브인터페이스가 이긴다. 상속관계를 갖는 인터페이스에서 같은 시그니처를 갖는 메서드를 정의할 때는 서브인터페이스가 이긴다. 즉, B가 A를 상속받는다면 B가 A를 이긴다.
3. 여전히 디폴트 메서드의 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스가 명시적으로 디폴트 메서드를 오버라이드하고 호출해야 한다.