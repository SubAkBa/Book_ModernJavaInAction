## 1.2 왜 아직도 자바는 변화하는가?
현실적으로 완벽한 언어는 존재하지 않으며 모든 언어가 장단점을 갖고 있다.

- ex) C, C++은 작은 런타임 footprint 덕분에 OS와 다양한 임베디드 시스템에서 여전히 인기가 있지만, 낮은 안정성 때문에 프로그램이 예기치 않게 종료되거나 보안 구멍이 있을 수 있다.
 - footprint : 특정 하드웨어나 소프트웨어 단위가 차지하고 있는 공간의 크기

### 1.2.1 프로그래밍 언어 생태계에서 자바의 위치
 
 **출발이 좋은 자바**
 
 - 처음부터 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작
 - 스레드와 락을 이용한 소소한 동시성 지원 (하드웨어 중립적인 메모리 모델 때문에 멀티코어 프로세서에서 병렬적으로 수행되는 스레드는 싱글코어에서의 동작과 달리 예기치 못한 상황을 일으킬 수 있다.)
 - 코드를 JVM 바이트 코드로 컴파일 (그리고 모든 브라우저에서 가상 머신 코드를 지원)

 > 자바는 어떻게 대중적인 프로그래밍 언어로 성장했는가?
 >
 > 객체지향은 두 가지 이유로 각광받았다.  
 > (1) 캡슐화 덕분에 C에 비해 소프트웨어 엔지니어링적인 문제가 훨씬 적다.  
 > (2) 객체지향의 정신적인 모델 덕분에 윈도우 95 및 그 이후의 WIMP 프로그래밍 모델에 쉽게 대응할 수 있다.  
 > WIMP : Window, Icon, Menu, Pointing
 

**프로그래밍 언어 생태계에 변화의 바람**

- 빅데이터 (테라바이트 이상의 데이터셋) 라는 도전에 직면하면서 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 빅데이터를 효과적으로 처리할 필요성 증가
 - 즉, 병렬 프로세싱을 활용해야 하지만 지금까지의 자바로는 충분한 대응 불가

 > 자바의 또 다른 기후 변화 요소
 >
 > 최근에는 외부에서 큰 하위시스템 컴포넌트를 추가하고 다른 벤더가 만든 컴포넌트를 이용해 개발하는 사례가 늘어나고 있다.  
 > 자바 8, 9에서는 이런 설계 스타일에 적응할 수 있도록 디폴트 메서드와 모듈을 제공한다.
 
### 1.2.2 스트림 처리
스트림 (Stream) : 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임

- 자바 8에는 java.util.stream 패키지에 스트림 API가 추가되었다. 스트림 패키지에 정의된 Stream<T>는 T 형식으로 구성된 일련의 항목을 의미한다.
- 스트림 API가 조립 라인처럼 어떤 항목을 연속으로 제공하는 어떤 기능이라고 단순하게 생각했을 때, 스트림 API는 파이프라인을 만드는 데 필요한 많은 메서드를 제공한다.
 - 파이프라인 (Pipeline) : 한 데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 형태로 연결된 구조
- 스트림 API의 핵심은 기존에는 어떤 작업에 대해 한 번에 한 항목을 처리했지만, 이를 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다.
- 또한, 스트림 파이프라인을 이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있고, 스레드라는 복잡한 작업을 사용하지 않으면서 병렬성을 얻을 수 있다.

#### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기
2013UK0001, 2014US0002, ... 등의 형식을 갖는 송장 ID가 있다고 가정하자.

처음 네 개의 숫자는 연도를, 다음 두 글자는 국가 코드를, 마지막 네 개의 숫자는 고객ID를 의미한다. 

이제 이 송장ID를 고객 ID 또는 국가 코드순으로 정렬해야 한다. 우리가 지정하는 순서대로 자료를 정리하도록 sort 메서드에 명령을 내려야 한다. 우선은 compareUsingCustomerId 메서드를 구현할 수 있다.

그런데, 자바 8 이전에는 메서드를 다른 메서드로 전달할 방법이 없었다. Comparator 객체를 만들어서 sort에 넘겨주는 방법도 있지만 이는 너무 복잡하며 기존 동작을 단순하게 재활용한다는 측면에도 맞지 않다.

자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다. 

> 이러한 기능을 이론적으로 동작 파라미터화 (Behavior Parameterization) 라고 부른다.
> 
> 동작 파라미터화가 왜 중요할까?  
> 
> compareUsingCustomerId를 이용해 sort의 동작을 파라미터화했던 것처럼 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문이다.

### 1.2.4 병렬성과 공유 가변 데이터

병렬성을 얻는 대신 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 한다.

스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행되더라도 안전하게 실행될 수 있어야 한다.

보통 다른 코드와 동시에 실행하더라도 **안전하게 실행**할 수 있는 코드를 만들려면 공유된 가변 데이터 (Shared Mutable Data) 에 접근하지 않아야 한다.
> 이러한 함수를 순수 (Pure) 함수, 부작용 없는 (Side-Effect-Free) 함수, 상태 없는 (Stateless) 함수라 부른다.

**예를 들어 두 프로세스가 공유된 변수를 동시에 바꾸려 하면 어떻게 될까?**
다중 프로세싱 코어에서 synchronized를 사용하면 생각보다 훨씬 더 비싼 대가를 치러야 할 수 있다.
> 성능에 영향을 미친다고 한다. [(참고)](https://crackjamx.wordpress.com/2013/02/07/java-synchronized-%EC%A3%BC%EC%9D%98%EC%A0%90/)

자바 8 스트림을 이용하면 기존의 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있다.
> **함수형 프로그래밍** 패러다임의 핵심적인 사항  
> 
> 공유되지 않은 가변 데이터 (No Shared Mutable Data), 메서드, 
> 함수 코드를 다른 메서드로 전달하는 기능

### 1.2.5 자바가 진화해야 하는 이유
지금까지 자바는 진화해왔다.

- Generic으로 인한 List -> List<String>
 - 컴파일을 할 때, 더 많은 에러 검출 가능
 - 리스트의 유형을 알 수 있어 가독성 향상
- 틀에 박힌 Iterator 대신 for-each 루프 사용