## 16.1 Future의 단순 활용
Future로 오래 걸리는 작업을 비동기적으로 실행하는 자바 8 이전의 예제 코드
```java
ExecutorService executor = Executors.newCachedThreadPool();      // <- 스레드 풀에 태스크를 제출하려면 ExecutorService를 만들어야 한다.
Future<Dobule> future = executor.submit(new Callable<Double>() { // <- Callable을 ExecutorService로 제출한다.
    public Double call() {
        return doSomeLongComputation(); // <- 시간이 오래 걸리는 작업은 다른 스레드에서 비동기적으로 실행한다.
    }
});

doSomethingElse();

try {
    Double result = future.get(1, TimeUnit.SECONDS); // <- 비동기 작업의 결과를 가져온다.
} catch (ExecutionException ee) {                    //    결과가 준비되어 있지 않으면 호출 스레드가 블록된다.
    // 계산 중 예외 발생                                 //    하지만 최대 1초까지만 기다린다.
} catch (InterruptedException ie) {
    // 현재 스레드에서 대기 중 인터럽트 발생
} catch (TimeoutException te) {
    // Future가 완료되기 전에 타임아웃 발생
}
```

ExecutorService에서 제공하는 스레드가 시간이 오래 걸리는 작업을 처리하는 동안 우리 스레드로 다른 작업을 동시에 실행할 수 있다.

다른 작업을 처리하다가 시간이 오래 걸리는 작업의 결과가 필요한 시점이 되었을 때 Future의 get 메서드로 결과를 가져올 수 있다.
get 메서드를 호출했을 때 이미 계산이 완료되어 결과가 준비되었다면 즉시 결과를 반환하지만 결과가 준비되지 않았다면 작업이 완료될 때까지 우리 스레드를 블록시킨다.
> 오래 걸리는 작업이 영원히 끝나지 않으면 어떻게 될까?
> 
> 작업이 끝나지 않는 문제가 있을 수 있으므로 get 메서드를 오버로드해서 우리 스레드가 대기할 최대 타임아웃 시간을 설정하는 것이 좋다.

### 16.1.1 Future 제한
선언형 기능이 있다면 유용할 것이다.
- 두 개의 비동기 계산 결과를 하나로 합친다. 두 가지 계산 결과는 서로 독립적일 수 있으며 또는 두 번째 결과가 첫 번째 결과에 의존하는 상황일 수 있다.
- Future 집합이 실행하는 모든 태스크의 완료를 기다린다.
- Future 집합에서 가장 발리 완료되는 태스크를 기다렸다가 결과를 얻는다 (예를 들어 여러 태스크가 다양한 방식으로 같은 결과를 구하는 상황).
- 프로그램적으로 Future를 완료시킨다 (즉, 비동기 동작에 수동으로 결과 제공).
- Future 완료 동작에 반응한다 (즉, 결과를 기다리면서 블록되지 않고 결과가 준비되었다는 알림을 받은 다음에 Future의 결과로 원하는 추가 동작을 수행할 수 있음).

### 16.1.2 CompletableFuture로 비동기 애플리케이션 만들기
어떤 제품이나 서비스를 이용해야 하는 상황이라고 가정하자.

예산을 줄일 수 있도록 여러 온라인상점 중 가장 저렴한 가격을 제시하는 상점을 찾는 애플리케이션을 완성해가는 예제를 이용해서 CompletableFuture의 기능을 살펴보자.
1. 고객에게 비동기 API를 제공하는 방법을 배운다 (온라인상점을 운영하고 있는 독자에게 특히 유용한 기술).
2. 동기 API를 사용해야 할 때 코드를 비블록으로 만드는 방법을 배운다. 두 개의 비동기 동작을 파이프라인으로 만드는 방법과 두 개의 동작 결과를 하나의 비동기 계산으로 합치는 방법을 살펴본다.
3. 비동기 동작의 완료에 대응하는 방법을 배운다. 즉, 모든 상점에서 가격 정보를 얻을 때까지 기다리는 것이 아니라 각 상점에서 가격 정보를 얻을 때마다 즉시 최저가격을 찾는 애플리케이션을 갱신하는 방법을 설명한다 (그렇지 않으면 서버가 다운되는 등 문제가 발생했을 때 사용자에게 검은 화면만 보여주게 될 수 있다).

> 동기 API와 비동기 API
> 
> 동기 API - 메서드를 호출한 따음에 메서드가 계산을 완료할 때까지 기다렸다가 메서드가 반환되면 호출자는 반환된 값으로 계속 다른 동작을 수행한다.
> 호출자와 피호출자가 각각 다른 스레드에서 실행되는 상황이었더라도 호출자는 비호출자의 동작 완료를 기다렸을 것이다.
> 
> 이처럼 동기 API를 사용하는 상황을 **블록 호출**이라고 한다.
> 
> 비동기 API - 메서드가 즉시 반환되며 끝내지 못한 나머지 작업을 호출자 스레드와 동기적으로 실행될 수 있도록 다른 스레드에 할당한다.
> 
> 이와 같은 비동기 API를 사용하는 상황을 **비블록 호출**이라고 한다.
> 다른 스레드에 할당된 나머지 계산 결과는 콜백 메서드를 호출해서 전달하거나 호출자가 '계산 결과가 끝날 때까지 기다림' 메서드를 추가로 호출하면서 전달된다.
> 즉, 계산 동작을 수행하는 동안 비동기적으로 디스크 접근을 수행한다. 그리고 더 이상 수행할 동작이 없으면 디스크 블록이 메모리로 로딩될 때까지 기다린다.