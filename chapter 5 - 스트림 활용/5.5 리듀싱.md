## 5.5 리듀싱
리듀싱 연산 : 모든 스트림 요소를 처리해서 값으로 도출한다.

함수형 프로그래밍 언어 용어로는 이 과정이 마치 종이 (스트림) 를 작은 조각이 될 때까지 반복해서 접는 것과 비슷하다는 의미로 **폴드** 라고 부른다.

### 5.5.1 요소의 합
for-each 루프를 이용해서 리스트의 숫자 요소를 더하는 코드
```java
int sum = 0;

for (int x : numbers) {
    sum += x;
}
```
코드에는 파라미터 두 개를 사용했다.

(1) sum 변수의 초깃값 0  
(2) 리스트의 모든 요소를 조합하는 연산 (+)

reduce를 이용한 코드
```java
int sum = numbers.stream().reduce(0, (a, b) -> a + b);
```

reduce는 두 개의 인수를 갖는다.

(1) 초깃값 0  
(2) 두 요소를 조합해서 새로운 값을 만드는 BinaryOperator<T>. 예제에서는 람다 표현식 (a, b) -> a + b를 사용했다.

**reduce가 스트림의 모든 숫자를 더하는 방식**
1. 람다의 첫 번째 파라미터 (a) 에 0이 사용되었고, 스트림에서 4를 소비해서 두 번째 파라미터 (b) 로 사용했다.
2. 0 + 4 결과인 4가 새로운 누적값이 되었다.
3. 누적값으로 람다를 다시 호출하며 다음 요소인 5를 소비하며, 결과는 9가 된다.
4. 이런 식으로 계산을 하고 마지막 누적값 12와 마지막 요소 9로 호출하면 최종적으로 21이 도출된다.

메서드 참조 이용
```java
int sum = numbers.stream().reduce(0, Integer::sum);
```

**초깃값 없음**
초깃값을 받지 않도록 오버로드된 reduce도 있지만, Optional 객체를 반환한다.
```java
Optional<Integer> sum = numbers.stream().reduce((a, b) -> (a + b));
```

> 왜 Optional<Integer> 를 반환하는 걸까?
>
> 스트림에 아무 요소가 없는 경우, 초깃값이 없기 때문에 reduce는 합계를 반환할 수 없다.  
> 따라서 합계가 없음을 가리킬 수 있도록 Optional 객체로 감싼 결과를 반환한다.

### 5.5.2 최댓값과 최솟값
reduce는 새로운 값을 이용해서 스트림의 모든 요소를 소비할 때까지 람다를 반복 수행하면서 최댓값을 생산한다.

```java
Optional<Integer> max = numbers.stream().reduce(Integer::max);
```

> reduce 메서드의 장점과 병렬화
>
> reduce를 이용하면 내부 반복이 추상화되면서 내부 구현에서 병렬로 reduce를 실행할 수 있게 된다.  
> 반복적인 합계에서는 sum 변수를 공유해야 하므로 쉽게 병렬화하기 어렵다. 강제적으로 동기화시키더라도
> 결국 병렬화로 얻어야 할 이득이 스레드 간의 소모적인 경재 때문에 상쇄되어 버린다.
> 
> ```java
> int sum = numbers.parallelStream().reduce(0, Integer::sum);
> ```
> 위 코드를 병렬로 실행하려면 reduce에 넘겨준 람다의 상태 (인스턴스 변수 같은) 가 바뀌지 말아야 하며,
> 연산이 어떤 순서로 실행되더라도 결과가 바뀌지 않는 구조여야 한다.

<br />

> 스트림 연산 : 상태 없음과 상태 있음
> 
> map, filter 등은 입력 스트림에서 각 요소를 받아 0 또는 결과를 출력 스트림으로 보낸다.  
> 따라서 (사용자가 제공한 람다나 메서드 참조가 내부적인 가변 상태를 갖지 않는다는 가정하에) 이들은 보통 상태가 없는,
> 즉 내부 상태를 갖지 않는 연산 (Stateless Operation) 이다.
>
> reduce, sum, max 같은 연산은 결과를 누적할 내부 상태가 필요하다.
> 스트림에서 처리하는 요소 수와 관계없이 내부 상태의 크기는 **한정 (Bounded)** 되어 있다.
>
> sorted나 distinct 같은 연산은 filter나 map과는 달리 스트림의 요소를 
> 정렬하거나 중복을 제거하려면 과거의 이력을 알고 있어야 한다. 
> 예를 들어 어떤요소를 출력 스트림으로 추가하려면 **모든 요소가 버퍼에 추가되어 있어야 한다.**  
> 연산을 수행하는 데 필요한 저장소 크기가 정해져 있지 않아, 데이터 스트림의 크기가 크거나 무한이라면 문제가 생길 수 있다.  
> 이러한 연산을 **내부 상태를 갖는 연산 (Stateful Operation)** 이라 한다.