## 17.1 리액티브 매니패스토
리액티브 애플리케이션과 시스템 개발의 핵심 원칙
- 반응성 (Responsive) : 리액티브 시스템은 빠를 뿐 아니라 더 중요한 특징으로 일정하고 예상할 수 있는 반응 시간을 제공한다. 결과적으로 사용자가 기대치를 가질 수 있다. 기대치를 통해 사용자의 확신이 증가하면서 사용할 수 있는 애플리케이션이라는 확인을 제공할 수 있다.
- 회복성 (Resilient) : 장애가 발생해도 시스템은 반응해야 한다. 컴포넌트 실행 복제, 여러 컴포넌트의 시간 (발송자와 수신자가 독립적인 생명주기를 가짐) 과 공간 (발송자와 수신자가 다른 프로세스에서 실행됨) 분리, 각 컴포넌트가 비동기적으로 작업을 다른 컴포넌트에 위임하는 등 리액티브 매니페스토는 회복성을 달성할 수 있는 다양한 기법을 제시한다.
- 탄력성 (Elastic) : 애플리케이션의 생명주기 동안 다양한 작업 부하를 받게 되는데 이 다양한 작업 부하로 애플리케이션의 반응성이 위협받을 수 있다. 리액티브 시스템에서는 무서운 작업 부하가 발생하면 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다.
- 메시지 주도 (Message-driven) : 회복성과 탄력성을 지원하려면 약한 결합, 고립, 위치 투명성 등을 지원할 수 있도록 시스템을 구성하는 컴포넌트의 경계를 명확하게 정의해야 한다. 비동기 메시지를 전달해 컴포넌트 끼리의 통신이 이루어진다. 이 덕분에 회복성 (장애를 메시지로 처리) 과 탄력성 (주고 받은 메시지의 수를 감시하고 메시지의 양에 따라 적절하게 리소스를 할당) 을 얻을 수 있다.

### 17.1.1 애플리케이션 수준의 리액티브
개발자 입장에서는 여러 기술 (이벤트, 메시지, 시그널, 이벤트 루프 등) 을 이용함으로 동시, 비동기 애플리케이션 구현의 추상 수준을 높일 수 있으므로 동기 블록, 경쟁 조건, 데드락 같은 저 수준의 멀티스레드 문제를 직접 처리할 필요가 없어지면서 비즈니스 요구사항을 구현하는 데 집중할 수 있다.

스레드를 다시 쪼개는 종류의 기술을 사용할 때는 메인 이벤트 루프 안에서는 절대 동작을 블럭하지 않아야 한다는 중요한 전제 조건이 항상 따른다.
> 데이터베이스나 파일 시스템 접근, 작업 완료까지 얼마나 걸릴지 예측이 힘든 원격 서비스 호출 등 모든 I/O 관련 동작이 블록 동작에 속한다.

예시
> 두 스레드를 포함하는 풀이 있고 이벤트 스트림 세 개를 처리하는 상황
> 
> 한 번에 오직 두 개의 스트림을 처리할 수 있는 상황이므로 가능하면 이들 스트림을 두 스레드를 효율적이고 공정하게 공유해야 한다.
> 
> 블록되는 API를 이용해 데이터베이스에서 파일을 가져오는 등 느린 I/O 작업이 시작되었다. 이런 상황에서 스레드 2는 I/O 동작이 끝나기를 기다리며 소모된다.
> 스레드 1은 여전히 첫 번째 스트림을 처리할 수 있지만 이전에 시작된 블록 동작이 끝나기 전까지 세 번째 스트림은 처리되지 못한다.

RxJava, Akka 같은 리액티브 프레임워크는 별도로 지정된 스레드 풀에서 블록 동작을 실행시켜 이 문제를 해결한다.
> 메인 풀의 모든 스레드는 방해받지 않고 실행되므로 모든 CPU 코어가 가장 최적의 상황에서 동작할 수 있다.

### 17.1.2 시스템 수준의 리액티브
메시지는 정의된 목적지 하나를 향하는 반면, 이벤트는 관련 이벤트를 관찰하도록 등록한 컴포넌트가 수신한다는 점에서 다르다.
리액티브 시스템에서는 수신자와 발신자가 각각 수신 메시지, 발신 메시지와 결합하지 않도록 이들 메시지를 비동기로 처리해야 한다.

좀 더 정확히 말해 리액티브 아키텍처에서는 컴포넌트에서 발생한 장애를 고립시킴으로 문제가 주변의 다른 컴포넌트로 전파되면서 전체 시스템 장애로 이어지는 것을 막음으로 회복성을 제공한다.

탄력성의 핵심은 위치 투명성이다. 위치 투명성 덕분에 시스템을 복제할 수 있으며 현재 작업 부하에 따라 (자동으로) 애플리케이션을 확장할 수 있다.
> 위치 투명성 : 리액티브 시스템의 모든 컴포넌트가 수신자의 위치에 상관없이 다른 모든 서비스와 통신할 수 있음을 의미